# -*- coding: utf-8 -*-
"""dnpScript.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1areGkGINlYRW3K9ix0NVGR5ALe0VrvSW

Ejercicio realizado por Javier Ibarra en Google colab utilizando la información disponible de los microdatos anonimizados de la GEIH 2023 (DANE)
Fuente: https://microdatos.dane.gov.co/index.php/catalog/782/get-microdata

La información fue subida a Google Drive
"""

# dependencias
from google.colab import drive
drive.mount('/content/drive')
import pandas as pd
import os

# Esta función sirve para cargar datos a colab con exclusivamente las columnas relevantes y hacer el cruce inicial
# Para este ejercicio, cargué la información mensual de 2023 de los módulos de ocupados y características generales, seguridad social en salud y educación

def cargar_y_cruzar_datos(meses, ruta_base):
    caracteristicas_list = []
    ocupados_list = []

    for mes in meses:
        ruta_carpeta = os.path.join(ruta_base, mes)

        try:
            # Se cargan las columnas relevantes de características
            caracteristicas = pd.read_csv(
                os.path.join(ruta_carpeta, 'Características generales, seguridad social en salud y educación.CSV'),
                encoding='latin1',
                sep=';',
                usecols=['DIRECTORIO', 'SECUENCIA_P', 'ORDEN', 'P3271', 'P6040', 'P6070', 'P6071', 'P6050', 'P6100', 'FEX_C18'],
                low_memory=False
            )

            # Se cargan las columnas relevantes de ocupados
            ocupados = pd.read_csv(
                os.path.join(ruta_carpeta, 'Ocupados.CSV'),
                encoding='latin1',
                sep=';',
                usecols=['DIRECTORIO', 'SECUENCIA_P', 'ORDEN', 'OCI'], # no se carga 'FEX_C18' pues se hace el merge con el anterior módulo
                low_memory=False
            )

            # Se crea la llave de cruce en cada módulo
            # El directorio identifica la vivienda. La secuencia_p identifica el hogar. La variable orden hace referencia a las personas.
            caracteristicas['llave_cruce'] = caracteristicas['DIRECTORIO'].astype(str) + '-' + caracteristicas['SECUENCIA_P'].astype(str) + '-' + caracteristicas['ORDEN'].astype(str)
            ocupados['llave_cruce'] = ocupados['DIRECTORIO'].astype(str) + '-' + ocupados['SECUENCIA_P'].astype(str) + '-' + ocupados['ORDEN'].astype(str)

            # Se añaden los DataFrames a las listas creadas inicialmente vacías
            caracteristicas_list.append(caracteristicas)
            ocupados_list.append(ocupados)

        # Si se llegara a presentar un error de carga, este catch permite identificar el archivo con problemas
        # me pasó haciendo pruebas que uno de los meses en csv tenía tipo de separador distinto a los restantes 11 meses, lo que permitió identificarlo rapidamente
        except Exception as e:
            print(f"Error al cargar los archivos del mes {mes}: {e}")

    # Se concatenan los DataFrames de todos los meses del año 2023 en ambos módulos
    caracteristicas_total = pd.concat(caracteristicas_list, ignore_index=True)
    ocupados_total = pd.concat(ocupados_list, ignore_index=True)

    # Se cruzan los módulos mediante las llaves
    datos_cruzados = pd.merge(caracteristicas_total, ocupados_total, on='llave_cruce', how='left')

    return datos_cruzados

# Función para filtrar mujeres de 15 a 54 años y hacer los cálculos
def calcular_totales(datos_cruzados):

    # Se calcula el número total de ocupados
    total_ocupados = datos_cruzados[datos_cruzados['OCI'] == 1]['FEX_C18'].sum() / 12
    print(f"Número total de ocupados enero - diciembre 2023: {total_ocupados}")

    # Se filtran mujeres de 15 a 54 años
    mujeres_filtro = (datos_cruzados['P3271'] == 2) & (datos_cruzados['P6040'] >= 15) & (datos_cruzados['P6040'] <= 54)
    total_mujeres_15_54 = datos_cruzados[mujeres_filtro]['FEX_C18'].sum()/12
    print(f"Número de mujeres de 15 a 54 años enero - diciembre 2023: {total_mujeres_15_54}")

    # Se filtran mujeres casadas o en unión libre
    estado_civil_filtro = datos_cruzados['P6070'].isin([2, 3])
    mujeres_casadas_union = datos_cruzados[mujeres_filtro & estado_civil_filtro]
    total_mujeres_casadas_union = mujeres_casadas_union['FEX_C18'].sum()/12
    print(f"Número de mujeres de 15 a 54 años y están casadas o en unión libre enero - diciembre 2023: {total_mujeres_casadas_union}")

    # Se filtran mujeres que conviven con su pareja
    conyuge_filtro = datos_cruzados['P6071'] == 1
    mujeres_con_pareja = datos_cruzados[mujeres_filtro & estado_civil_filtro & conyuge_filtro]
    total_mujeres_con_pareja = mujeres_con_pareja['FEX_C18'].sum()/12
    print(f"Número de mujeres de 15 a 54 años y están casadas o en unión libre, conviven con su pareja enero - diciembre 2023: {total_mujeres_con_pareja}")

    # Se filtran mujeres cuya pareja está ocupada (OCI == 1)
    pareja_ocupada_filtro = mujeres_con_pareja['OCI'] == 1
    mujeres_con_pareja_ocupada = mujeres_con_pareja[pareja_ocupada_filtro]
    total_mujeres_con_pareja_ocupada = mujeres_con_pareja_ocupada['FEX_C18'].sum()/12
    print(f"Número de mujeres de 15 a 54 años y están casadas o en unión libre, conviven con su pareja y el cónyuge es un ocupado enero - diciembre 2023: {total_mujeres_con_pareja_ocupada}")

    # Se filtran mujeres cuya pareja está ocupada y afiliada a EPS contributiva (P6100 == 1)
    pareja_contributiva_filtro = mujeres_con_pareja_ocupada['P6100'] == 1
    mujeres_con_pareja_ocupada_contributiva = mujeres_con_pareja_ocupada[pareja_contributiva_filtro]
    total_mujeres_con_pareja_ocupada_contributiva = mujeres_con_pareja_ocupada_contributiva['FEX_C18'].sum()/12
    print(f"Número de mujeres de 15 a 54 años y están casadas o en unión libre, conviven con su pareja y el cónyuge es un ocupado y afiliado a EPS contributiva enero - diciembre 2023: {total_mujeres_con_pareja_ocupada_contributiva}")

# Lista de meses y ruta
meses = ['Ene_2023', 'Feb_2023', 'Mar_2023', 'Abr_2023', 'May_2023', 'Jun_2023', 'Jul_2023', 'Ago_2023', 'Sep_2023', 'Oct_2023', 'Nov_2023', 'Dic_2023']
ruta_base = '/content/drive/My Drive/Prueba_DNP_Subdireccion_Empleo_y_Seguridad_Social/GEIH_2023/'

# Se invoca la función principal de cargar y cruzar los datos
datos_cruzados = cargar_y_cruzar_datos(meses, ruta_base)

# Se invoca la función de cálculo de totales
calcular_totales(datos_cruzados)

